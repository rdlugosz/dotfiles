set nocompatible               " be iMproved

filetype off                   " required!
set rtp+=~/.vim/bundle/vundle/
call vundle#begin()

if exists(':Plugin')
  " let Vundle manage Vundle - must be first!
  " use commands PluginInstall, PluginUpdate, PluginClean
  Plugin 'gmarik/vundle'

  " Repeat.vim sets up bindings other plugins can use to make their commands
  " repeatable with the . command.
  " https://github.com/tpope/vim-repeat
  Plugin 'tpope/vim-repeat'

  " Fugitive is a highly-capable Git wrapper for Vim.
  " see :h fugitive
  " https://github.com/tpope/vim-fugitive
  Plugin 'tpope/vim-fugitive'

  Plugin 'tpope/vim-speeddating'
  Plugin 'tpope/vim-surround'
  Plugin 'tpope/vim-unimpaired'
  Plugin 'tpope/vim-eunuch'
  Plugin 'tpope/vim-commentary'

  " Interface enhancements
  Plugin 'jeetsukumaran/vim-buffergator'
  Plugin 'tpope/vim-characterize'
  Plugin 'kien/ctrlp.vim'
  if exists("*gettabvar")
    Plugin 'airblade/vim-gitgutter'
  endif
  Plugin 'scrooloose/nerdtree'
  Plugin 'godlygeek/tabular'
  Plugin 'nelstrom/vim-visual-star-search'
  Plugin 'vim-scripts/ZoomWin'
  Plugin 'mileszs/ack.vim'
  Plugin 'michaeljsmith/vim-indent-object'
  " Plugin 'bling/vim-airline'
  Plugin 'rdlugosz/vim-dragvisuals'
  Plugin 'mbbill/undotree'
  Plugin 'nathanaelkane/vim-indent-guides'
  Plugin 'wellle/targets.vim'

  " Colorschemes
  Plugin 'altercation/vim-colors-solarized.git'
  Plugin 'tpope/vim-vividchalk'
  Plugin 'vim-scripts/Zenburn'
  Plugin 'chriskempson/base16-vim'
  Plugin 'nanotech/jellybeans.vim'
  Plugin 'junegunn/seoul256.vim'
  Plugin 'tomasr/molokai'

  " Language support
  Plugin 'tpope/vim-cucumber'
  Plugin 'kchmck/vim-coffee-script'
  Plugin 'guns/vim-clojure-static'
  Plugin 'elixir-lang/vim-elixir'
  Plugin 'tpope/vim-endwise'
  Plugin 'tpope/vim-git'
  Plugin 'jnwhiteh/vim-golang'
  Plugin 'tpope/vim-haml'
  Plugin 'pangloss/vim-javascript'
  Plugin 'groenewege/vim-less'
  Plugin 'tpope/vim-markdown'
  Plugin 'mmalecki/vim-node.js'
  Plugin 'ajf/puppet-vim'
  Plugin 'tpope/vim-rails'
  Plugin 'tpope/vim-rake'
  Plugin 'skwp/vim-rspec'
  Plugin 'skalnik/vim-vroom'
  Plugin 'vim-ruby/vim-ruby'
  Plugin 'rosstimson/scala-vim-support'
  Plugin 'cakebaker/scss-syntax.vim'

  " Syntax checker for many languages
  " https://github.com/scrooloose/syntastic
  Plugin 'scrooloose/syntastic'

  Plugin 'tpope/vim-rbenv'
  Plugin 't9md/vim-ruby-xmpfilter'
  Plugin 'rizzatti/funcoo.vim'
  Plugin 'rizzatti/dash.vim'
  Plugin 'AndrewRadev/splitjoin.vim'
  Plugin 'ecomba/vim-ruby-refactoring'
  Plugin 'chrisbra/csv.vim'

  " Add a text object for Ruby blocks (ar / ir)
  Plugin 'kana/vim-textobj-user'
  Plugin 'nelstrom/vim-textobj-rubyblock'

  " Snippets are kind of languagey, but in own section
  " to make it clear snipmate depends on tlib and mw-utils.
  Plugin 'MarcWeber/vim-addon-mw-utils'
  Plugin 'tomtom/tlib_vim'
  Plugin 'garbas/vim-snipmate'
  Plugin 'honza/vim-snippets'

  " Lols
  Plugin 'koron/nyancat-vim'

  call vundle#end()
  filetype plugin indent on     " required!
endif
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" END VUNDLE CONFIG
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SETTINGS
" tpope/vim-sensible is inlined here & used as a baseline
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has('autocmd')
  filetype plugin indent on
endif
if has('syntax') && !exists('g:syntax_on')
  syntax enable
endif

set autoindent   " preserve indent level on newlines
set tabstop=2    " a tab is two spaces
set shiftwidth=2 " an autoindent (with <<) is two spaces
set expandtab    " use spaces, not tabs

set backspace=indent,eol,start

" By default, complete is set to: complete=.,w,b,u,t,i
" The 'i' means 'included files' and can result in major slowdowns
set complete-=i

set smarttab

" Don't assume numbers starting with zero are octal
set nrformats-=octal

set ttimeout
set ttimeoutlen=100

set incsearch     " incremental searching
set nohlsearch    " don't highlight matches
set ignorecase    " searches are case insensitive...
set smartcase     " ... unless they contain at least one capital letter

set laststatus=2  " always show the status line
set ruler         " show cursor position (overridden by statusline)
set showcmd       " show partial command in bottom-right
set showtabline=1 " Show tabline only when more than one tab exists

set wildmenu      " use tab completion on command line

" Controls the number of lines/chars to keep visible before scrolling
set scrolloff=1
set sidescrolloff=5
set sidescroll=1
set display+=lastline " show the last line that fits in window (vs '@@@@')

if &encoding ==# 'latin1' && has('gui_running')
  set encoding=utf-8
endif

" Changes what Vim displays for special chars like trailing space & tabs
set list " Show invisible characters
let &listchars = "tab:>-,trail:\u2591,extends:>,precedes:<,nbsp:\u00b7"

" The semicolon will cause Vim to search back (up) in the directory tree
if has('path_extra')
  setglobal tags-=./tags tags^=./tags;
endif

set autoread           " reload unchanged buffers when file changed outside vim
set fileformats+=mac   " should already be the default when compiled on mac

set history=1000       " remember more than 20 previous searches/commands

set tabpagemax=50      " max number of tab pages that can be opened

" Control what is preserved in the viminfo file
"   ! save and restore all-caps-named GLOBAL variables
"   ' number of files for which we should remember marks
"   < maximum line count of a register that is saved
"   s maximum byte count of a register that is saved
"   h disable the hlsearch when loading viminfo
"   no '/' specified means use value of 'history' for saving searches
"   no ':' specified means use value of 'history' for command line history
"   no '%' specified means don't save/reload the buffer list
"   no 'n<file>' specified means use default location for .viminfo
set viminfo=!,'100,<1000,s100,h

set sessionoptions-=options " exclude options from the :mksession command

" Load matchit.vim, but only if the user hasn't installed a newer version.
" Makes the % command jump to matching HTML tags, if/else/endif in Vim scripts, etc.
if !exists('g:loaded_matchit') && findfile('plugin/matchit.vim', &rtp) ==# ''
  runtime! macros/matchit.vim
endif

" During insert, ctrl+u will break undo sequence then delete all entered chars
inoremap <C-U> <C-G>u<C-U>

" Set colorscheme
" Allow color schemes to do bright colors without forcing bold.
if &t_Co == 8 && $TERM !~# '^linux'
  set t_Co=16
endif
if $TERM =~ "-256color"
  set t_Co=256
endif
set background=dark
silent! colorscheme base16-default

" Write swap and backup files in the event of a crash or accident
set swapfile
set directory=$TMPDIR,~/tmp,~/.vim/tmp,/tmp,/var/tmp
set backup
set backupdir=$TMPDIR,~/tmp,~/.vim/tmp,/tmp,/var/tmp

" Extend our undoable steps and preserve over restart (if available)
if has('persistent_undo')
  set undodir=$TMPDIR,~/tmp,~/.vim/tmp,/tmp,/var/tmp
  set undofile
  set undoreload=10000
end
set undolevels=10000

" Keep our custom dictionary on Dropbox to sync across systems
set spelllang=en
set spellfile=$HOME/Dropbox/vim/en.utf-8.add,$HOME/.vim/en.utf-8.add

" Line numbering
" Relativenumber treats the current line as line 0 and is helpful for motions
if exists('+relativenumber')
  set relativenumber
end
" Setting number after Relativenumber replaces the '0' with the true number
set number

set nowrap        " don't wrap lines (we map leader-W to toggle)
set linebreak     " when wrapping, wrap at word boundaries (vs last char)
if exists('+breakindent')
  set breakindent " preserves the indent level of wrapped lines
  set showbreak=↪ " illustrate wrapped lines
  set wrap        " wrapping with breakindent is tolerable
endif
" When on first/last char in a line, allow left/right to navigate
" through to the prev/next line.
set whichwrap+=<,>,h,l

" cpoptions is a sequence of single-char flags that make Vim do different
" things. The $ flag enables showing a $ marker at the end boundary of cw
set cpoptions+=$

" allow modified buffers to be hidden
set hidden

" exclusions from the autocomplete menu
set wildignore+=*/tmp/*

" mouse works in most terminal software we use...
set mouse=a

" change the cursor shape depending on mode
" see: http://vim.wikia.com/wiki/Change_cursor_shape_in_different_modes
if exists('$TMUX')
  let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
  let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
else
  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

" Syntastic config
let g:syntastic_error_symbol = '✗'
let g:syntastic_warning_symbol = '⚠'
let g:syntastic_full_redraws = 1
let g:syntastic_auto_jump = 2         " Jump to syntax errors
let g:syntastic_auto_loc_list = 1     " Auto-open the error list

" Buffergator config
let g:buffergator_show_full_directory_path = 0
let g:buffergator_viewport_split_policy = 'T'

" Use par to reflow text
" see: http://vimcasts.org/episodes/formatting-text-with-par/
" Using `gw` will reflow with Vim's built-in algorithm.
if executable('par')
  set formatprg="par -h -w78 -B=.,\?_A_a "
endif

" Remember last location in file, but not for commit messages.
" see :help last-position-jump
au BufReadPost * if &filetype !~ '^git\c' && line("'\"") > 0 && line("'\"") <= line("$") | exe "normal! g`\"" | endif

" Use The Silver Searcher if available
if executable('ag')
  set grepprg=ag\ --nogroup\ --nocolor

  " Use ag in CtrlP
  let g:ctrlp_user_command = 'ag %s -l --nocolor --hidden -g ""'

  " Skip caching since ag is so fast
  let g:ctrlp_use_caching = 0

  " Use ag in ack.vim
  let g:ackprg = 'ag --nogroup --nocolor --column'
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""
" STATUS LINE
" see: :help 'statusline
"""""""""""""""""""""""""""""""""""""""""""""""""""""""
set statusline=         "reset
set statusline+=%#todo# "set color
set statusline+=[       "open bracket char
set statusline+=%n      "buffer number
set statusline+=%M      "modifiable/modified flag
set statusline+=%R      "Readonly flag
set statusline+=%W      "Preview window flag
set statusline+=]%*     "close bracket & reset color
set statusline+=%<      "cut from here if line is too long
set statusline+=./%f    "relative path of the filename
set statusline+=[%{strlen(&fenc)?&fenc:'wtf-enc'}\| "file encoding
set statusline+=%{&ff}\| "file format
set statusline+=%{strlen(&ft)?&ft:'zomg'}] "file type
set statusline+=%=      "left/right separator
set statusline+=%{fugitive#statusline()}\  "git branch
set statusline+=%c,     "cursor column
set statusline+=%l/%L   "cursor line/total lines
set statusline+=\ (%P)  "escaped space, percent through file

"""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MAPPINGS
"""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Quick ESC
" Some people map jk for this, but it makes Dijkstra sad.
imap kj <ESC>

" make Y behave similarly to D and C
nnoremap Y y$

" Insert the Ruby hashrocket with CTRL+l
imap <c-l> <space>=><space>

" map j to gj and k to gk, so line navigation ignores line wrap
" ...but only if the count is undefined (otherwise, things like 4j
" break if wrapped LINES are present)
nmap <expr> j (v:count == 0 ? 'gj' : 'j')
nmap <expr> k (v:count == 0 ? 'gk' : 'k')

" Expand %% into the directory of the current file
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'

" Emacs-like beginning and end of line.
imap <c-e> <c-o>$
imap <c-a> <c-o>^

" Navigate splits more easily
nmap <C-h> <C-w>h
nmap <C-j> <C-w>j
nmap <C-k> <C-w>k
nmap <C-l> <C-w>l

" Key repeat hack for resizing splits, i.e., <C-w>+++- vs <C-w>+<C-w>+<C-w>-
" see: http://www.vim.org/scripts/script.php?script_id=2223
nmap <C-w>+ <C-w>+<SID>ws
nmap <C-w>- <C-w>-<SID>ws
nmap <C-w>> <C-w>><SID>ws
nmap <C-w>< <C-w><<SID>ws
nnoremap <script> <SID>ws+ <C-w>+<SID>ws
nnoremap <script> <SID>ws- <C-w>-<SID>ws
nnoremap <script> <SID>ws> <C-w>><SID>ws
nnoremap <script> <SID>ws< <C-w><<SID>ws
nmap <SID>ws <Nop>

" Allow writing via sudo
cnoremap w!! w !sudo tee > /dev/null %

" Allow for some common quit/write cmd typos
command! Q q " Bind :Q to :q
command! W w " Bind :W to :w
command! Qall qall

"""""""""""""""""""""""""""""""""""""""""""""""""""""""
" LEADER MAPPINGS
"""""""""""""""""""""""""""""""""""""""""""""""""""""""
" let spacebar double as our leader, for great justice
nmap <space> <leader>
nmap <space><space> <leader><leader>

" Reload our .vimrc
nmap <leader>~ :source ~/.vimrc<CR>:redraw<CR>:echo "~/.vimrc reloaded!"<CR>

" Write file
nmap <leader>w :w<CR>

" Delete buffer
nmap <leader>q :bd<CR>

" Toggle spelling
nmap <leader>s :set invspell<CR>:set spell?<CR>

" Toggle wrap
nmap <leader>W :set invwrap<CR>:set wrap?<CR>

" Toggle Cursor Column
nmap <leader>c :set invcursorcolumn<CR>

" Toggle paste mode
nmap <leader>p :set invpaste<CR>:set paste?<CR>
imap <silent> <F4> <ESC>:set invpaste<CR>:set paste?<CR>

" upper/lower word
" (set a mark, visually select inner word, u/U, return to mark)
nmap <leader>U m`viwU``
nmap <leader>L m`viwu``

" Reindent the entire file
nmap <leader>= gg=G``:echo "reindent global"<CR>

" delete trailing whitespace
" http://vim.wikia.com/wiki/Remove_unwanted_spaces
function! RD_RemoveTrailingSpaces()
  " set a mark to return to later
  normal m`
  " save the user's search register
  let _lastsearch=@/
  " find any space/tab at ends of lines & remove
  " the 'e' suppresses error if none found
  %s/\s\+$//e
  " restore the search register
  let @/=_lastsearch
  " jump back to the mark we set
  normal ``
  echo "removed trailing spaces (if any)"
endfunction
nmap <leader>tw :call RD_RemoveTrailingSpaces()<CR>

" Toggle match highlight
nmap <leader>l :set invhlsearch<CR>

" Highlight matches when jumping to next
function! HLNext (blinktime)
  highlight WhiteOnRed ctermfg=white ctermbg=red
  let [bufnum, lnum, col, off] = getpos('.')
  let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
  let target_pat = '\c\%#'.@/
  let ring = matchadd('WhiteOnRed', target_pat, 101)
  redraw
  exec 'sleep ' . a:blinktime . 'm'
  call matchdelete(ring)
  redraw
endfunction
" Now, remap n/N so they call themselves, center screen & call HLNext
nnoremap <silent> n nzz:call HLNext(300)<cr>
nnoremap <silent> N Nzz:call HLNext(300)<cr>

" bind K to grep word under cursor
nmap K :grep! "\b<C-R><C-W>\b"<CR>:cw<CR>

" NERDTree stuff
nmap <leader>n :NERDTreeToggle<CR>
let NERDTreeHijackNetrw=1

" UndoTree
nmap <leader>u :UndotreeToggle<CR>

" Fugitive mappings
nmap <leader>gs :Gstatus<cr>
nmap <leader>gc :Gcommit<cr>
nmap <leader>gd :Gdiff<cr>
nmap <leader>gp :Git push<cr>

" Mappings for vim-ruby-xmpfilter
if executable('xmpfilter')
  autocmd FileType ruby nmap <buffer> <leader>m <Plug>(xmpfilter-mark)
  autocmd FileType ruby xmap <buffer> <leader>m <Plug>(xmpfilter-mark)
  autocmd FileType ruby imap <buffer> <leader>m <Plug>(xmpfilter-mark)
  autocmd FileType ruby nmap <buffer> <leader>x <Plug>(xmpfilter-run)
  autocmd FileType ruby xmap <buffer> <leader>x <Plug>(xmpfilter-run)
  autocmd FileType ruby imap <buffer> <leader>x <Plug>(xmpfilter-run)
endif

" Key mappings for vim-dragvisuals
vmap  <expr>  <LEFT>   DVB_Drag('left')
vmap  <expr>  <RIGHT>  DVB_Drag('right')
vmap  <expr>  <DOWN>   DVB_Drag('down')
vmap  <expr>  <UP>     DVB_Drag('up')

" Tabular.vim
nnoremap <Leader>t= :Tabularize assignment<CR>
vnoremap <Leader>t= :Tabularize assignment<CR>
nnoremap <Leader>t: :Tabularize symbol<CR>
vnoremap <Leader>t: :Tabularize symbol<CR>
nnoremap <Leader>t, :Tabularize comma<CR>
vnoremap <Leader>t, :Tabularize comma<CR>

" Mac OS X-only mappings
if has("unix")
  let s:uname = system("uname -s")
  if s:uname == "Darwin\n"

    " Search for word under cursor in Dash.app
    nmap <leader>d <Plug>DashSearch
    nmap <leader>D <Plug>DashGlobalSearch

    " Use Marked.app to preview Markdown files...
    " http://stackoverflow.com/questions/9212340/is-there-a-vim-plugin-for-preview-markdown-file
    function! s:setupMarkup()
      nmap <leader>M :silent !open -a Marked.app '%:p'<CR>:redraw!<CR>
    endfunction
    au BufRead,BufNewFile *.{md,markdown,mdown,mkd,mkdn} call s:setupMarkup()

  endif
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""
" FILE TYPES
"""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Some file types should wrap their text
function! s:setupWrapping()
  set wrap
  set linebreak
  set textwidth=78
  set nolist
endfunction

" Make sure all markdown files have the correct filetype set and setup wrapping
au BufRead,BufNewFile *.{md,markdown,mdown,mkd,mkdn,txt} setf markdown
au FileType markdown call s:setupWrapping()
au FileType markdown setlocal ts=4 sts=4 sw=4

" enable spell checking on certain files
autocmd BufNewFile,BufRead COMMIT_EDITMSG set spell

" Treat JSON files like JavaScript
au BufNewFile,BufRead *.json set ft=javascript

" vim:set ft=vim et sw=2:
